#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class BinaryEvent(object):
    """
    Attributes:
     - data
    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BinaryEvent')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data is None:
            raise TProtocolException(message='Required field data is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SubscribeEvent(object):
    """
    Attributes:
     - topic
    """


    def __init__(self, topic=None,):
        self.topic = topic

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SubscribeEvent')
        if self.topic is not None:
            oprot.writeFieldBegin('topic', TType.STRING, 1)
            oprot.writeString(self.topic.encode('utf-8') if sys.version_info[0] == 2 else self.topic)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topic is None:
            raise TProtocolException(message='Required field topic is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SubscribeAllEvent(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SubscribeAllEvent')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoginAck(object):
    """
    Response for Login

    Attributes:
     - msg
    """


    def __init__(self, msg="OK",):
        self.msg = msg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoginAck')
        if self.msg is not None:
            oprot.writeFieldBegin('msg', TType.STRING, 1)
            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.msg is None:
            raise TProtocolException(message='Required field msg is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EventHeader(object):
    """
    Will be sent as a header for all events

    Attributes:
     - target: Regular Expression describing the targets which should receive this event
     - source: Source id of the client who has sent this event
    If missing the server will attach it.
     - time: Time in milliseconds since the unix epoch (time of the source's computer)
    If missing the server will attach it with its current time
     - uuid: Randomly chosen identifier. Used together with time for duplicate detection.
     - topic: The name of the event. i.e. "PingEvent"
    """


    def __init__(self, target=".*", source=None, time=None, uuid=None, topic=None,):
        self.target = target
        self.source = source
        self.time = time
        self.uuid = uuid
        self.topic = topic

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.target = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.uuid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.topic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EventHeader')
        if self.target is not None:
            oprot.writeFieldBegin('target', TType.STRING, 1)
            oprot.writeString(self.target.encode('utf-8') if sys.version_info[0] == 2 else self.target)
            oprot.writeFieldEnd()
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRING, 2)
            oprot.writeString(self.source.encode('utf-8') if sys.version_info[0] == 2 else self.source)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I64, 3)
            oprot.writeI64(self.time)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.I64, 4)
            oprot.writeI64(self.uuid)
            oprot.writeFieldEnd()
        if self.topic is not None:
            oprot.writeFieldBegin('topic', TType.STRING, 5)
            oprot.writeString(self.topic.encode('utf-8') if sys.version_info[0] == 2 else self.topic)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topic is None:
            raise TProtocolException(message='Required field topic is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SheepEvent(object):
    """
    Sheep Events will be acceptable by any client. After receiving it will put
    the string in wool on the std output.

    Attributes:
     - wool: What you want to sheep.
    """


    def __init__(self, wool=None,):
        self.wool = wool

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.wool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SheepEvent')
        if self.wool is not None:
            oprot.writeFieldBegin('wool', TType.STRING, 1)
            oprot.writeString(self.wool.encode('utf-8') if sys.version_info[0] == 2 else self.wool)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.wool is None:
            raise TProtocolException(message='Required field wool is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PingEvent(object):
    """
    PingEvent Clients will automatically respond with a PongEvent if this event is processed.

    Attributes:
     - requestTime: Time of the client who requests the ping
    """


    def __init__(self, requestTime=None,):
        self.requestTime = requestTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.requestTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PingEvent')
        if self.requestTime is not None:
            oprot.writeFieldBegin('requestTime', TType.I64, 1)
            oprot.writeI64(self.requestTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.requestTime is None:
            raise TProtocolException(message='Required field requestTime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PongEvent(object):
    """
    Pong Event is needed to reply to Ping Events

    Attributes:
     - requestTime: time of the request copied from the client.
     - responseTime: time of the response
    """


    def __init__(self, requestTime=None, responseTime=None,):
        self.requestTime = requestTime
        self.responseTime = responseTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.requestTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.responseTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PongEvent')
        if self.requestTime is not None:
            oprot.writeFieldBegin('requestTime', TType.I64, 1)
            oprot.writeI64(self.requestTime)
            oprot.writeFieldEnd()
        if self.responseTime is not None:
            oprot.writeFieldBegin('responseTime', TType.I64, 2)
            oprot.writeI64(self.responseTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.requestTime is None:
            raise TProtocolException(message='Required field requestTime is unset!')
        if self.responseTime is None:
            raise TProtocolException(message='Required field responseTime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConnectionEstablishedEvent(object):
    """
    Sent by TECS-Server to inform others about joining and leaving clients

    Attributes:
     - clientId
     - clientIP
    """


    def __init__(self, clientId=None, clientIP=None,):
        self.clientId = clientId
        self.clientIP = clientIP

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clientIP = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConnectionEstablishedEvent')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        if self.clientIP is not None:
            oprot.writeFieldBegin('clientIP', TType.STRING, 2)
            oprot.writeString(self.clientIP.encode('utf-8') if sys.version_info[0] == 2 else self.clientIP)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clientId is None:
            raise TProtocolException(message='Required field clientId is unset!')
        if self.clientIP is None:
            raise TProtocolException(message='Required field clientIP is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConnectionLostEvent(object):
    """
    Attributes:
     - clientId
     - clientIP
    """


    def __init__(self, clientId=None, clientIP=None,):
        self.clientId = clientId
        self.clientIP = clientIP

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clientIP = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConnectionLostEvent')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        if self.clientIP is not None:
            oprot.writeFieldBegin('clientIP', TType.STRING, 2)
            oprot.writeString(self.clientIP.encode('utf-8') if sys.version_info[0] == 2 else self.clientIP)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clientId is None:
            raise TProtocolException(message='Required field clientId is unset!')
        if self.clientIP is None:
            raise TProtocolException(message='Required field clientIP is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Version(object):
    """
    Attributes:
     - major
     - minor
     - patch
    """


    def __init__(self, major=None, minor=None, patch=None,):
        self.major = major
        self.minor = minor
        self.patch = patch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.major = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.minor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.patch = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Version')
        if self.major is not None:
            oprot.writeFieldBegin('major', TType.I32, 1)
            oprot.writeI32(self.major)
            oprot.writeFieldEnd()
        if self.minor is not None:
            oprot.writeFieldBegin('minor', TType.I32, 2)
            oprot.writeI32(self.minor)
            oprot.writeFieldEnd()
        if self.patch is not None:
            oprot.writeFieldBegin('patch', TType.I32, 3)
            oprot.writeI32(self.patch)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.major is None:
            raise TProtocolException(message='Required field major is unset!')
        if self.minor is None:
            raise TProtocolException(message='Required field minor is unset!')
        if self.patch is None:
            raise TProtocolException(message='Required field patch is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ServiceDescriptor(object):
    """
    A service that runs in an IP network.

    Attributes:
     - uuid: Unique identifier for this instance. e.g. a UUID
    It is used to merge same services on different networks
     - type: Unique identifier for the type of the service.
    e.g. your.domain.com/services/YourService,
         MyAudioService or
         CookieService
     - version: Version of the service.
     - uri: URI describes the resource in a user space defined way.
    tecs uses,
      - socket://0.0.0.0:0       => discovery
      - socket://0.0.0.0:1234    => discovery
      - socket://host:port
    If you use URI_HOST inside a string it will be replaced with the correct network host.
     - arguments: Placeholder #1 to encode additional information.
     - data: Custom data of the service.
     - context
    """


    def __init__(self, uuid=None, type=None, version=None, uri=None, arguments=None, data=None, context="",):
        self.uuid = uuid
        self.type = type
        self.version = version
        self.uri = uri
        self.arguments = arguments
        self.data = data
        self.context = context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.version = Version()
                    self.version.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.uri = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.MAP:
                    self.arguments = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.arguments[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readBinary()
                        self.data.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.context = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ServiceDescriptor')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 1)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 2)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRUCT, 3)
            self.version.write(oprot)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin('uri', TType.STRING, 5)
            oprot.writeString(self.uri.encode('utf-8') if sys.version_info[0] == 2 else self.uri)
            oprot.writeFieldEnd()
        if self.arguments is not None:
            oprot.writeFieldBegin('arguments', TType.MAP, 10)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.arguments))
            for kiter13, viter14 in self.arguments.items():
                oprot.writeString(kiter13.encode('utf-8') if sys.version_info[0] == 2 else kiter13)
                oprot.writeString(viter14.encode('utf-8') if sys.version_info[0] == 2 else viter14)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 11)
            oprot.writeListBegin(TType.STRING, len(self.data))
            for iter15 in self.data:
                oprot.writeBinary(iter15)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.context is not None:
            oprot.writeFieldBegin('context', TType.STRING, 12)
            oprot.writeString(self.context.encode('utf-8') if sys.version_info[0] == 2 else self.context)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.uri is None:
            raise TProtocolException(message='Required field uri is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DiscoverEvent(object):
    """
    Requests a service based on type and context.

    Attributes:
     - typeRegex: A regex that matches the desired service types.
     - context
    """


    def __init__(self, typeRegex=None, context="",):
        self.typeRegex = typeRegex
        self.context = context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.typeRegex = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.context = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DiscoverEvent')
        if self.typeRegex is not None:
            oprot.writeFieldBegin('typeRegex', TType.STRING, 1)
            oprot.writeString(self.typeRegex.encode('utf-8') if sys.version_info[0] == 2 else self.typeRegex)
            oprot.writeFieldEnd()
        if self.context is not None:
            oprot.writeFieldBegin('context', TType.STRING, 2)
            oprot.writeString(self.context.encode('utf-8') if sys.version_info[0] == 2 else self.context)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.typeRegex is None:
            raise TProtocolException(message='Required field typeRegex is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AdvertiseEvent(object):
    """
    Answers a DiscoverEvent.

    Attributes:
     - services
    """


    def __init__(self, services=None,):
        self.services = services

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.services = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = ServiceDescriptor()
                        _elem21.read(iprot)
                        self.services.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AdvertiseEvent')
        if self.services is not None:
            oprot.writeFieldBegin('services', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.services))
            for iter22 in self.services:
                iter22.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.services is None:
            raise TProtocolException(message='Required field services is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IPResolveRequest(object):
    """
    Request to resolve the IP address of the sender.

    Attributes:
     - requestId: The corresponding response(s) contain this id. See IPResolveResponse::responseId
     - port: The answer will be sent via UDP unicast to this port using the host of the received
    UDP message.
    """


    def __init__(self, requestId=None, port=None,):
        self.requestId = requestId
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.requestId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IPResolveRequest')
        if self.requestId is not None:
            oprot.writeFieldBegin('requestId', TType.STRING, 1)
            oprot.writeString(self.requestId.encode('utf-8') if sys.version_info[0] == 2 else self.requestId)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.requestId is None:
            raise TProtocolException(message='Required field requestId is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IPResolveResponse(object):
    """
    Contains the IP address of the sender. Multiple responses may be sent with different IPs if
    replying services are accessible through different interfaces (wifi / ethernet / localhost / ..)

    Attributes:
     - responseId: Contains the id of the corresponding request. See IPResolveRequest::requestId
     - ip: The ip of the requester.
    """


    def __init__(self, responseId=None, ip=None,):
        self.responseId = responseId
        self.ip = ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.responseId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IPResolveResponse')
        if self.responseId is not None:
            oprot.writeFieldBegin('responseId', TType.STRING, 1)
            oprot.writeString(self.responseId.encode('utf-8') if sys.version_info[0] == 2 else self.responseId)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 2)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responseId is None:
            raise TProtocolException(message='Required field responseId is unset!')
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(BinaryEvent)
BinaryEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
)
all_structs.append(SubscribeEvent)
SubscribeEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topic', 'UTF8', None, ),  # 1
)
all_structs.append(SubscribeAllEvent)
SubscribeAllEvent.thrift_spec = (
)
all_structs.append(LoginAck)
LoginAck.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'msg', 'UTF8', "OK", ),  # 1
)
all_structs.append(EventHeader)
EventHeader.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'target', 'UTF8', ".*", ),  # 1
    (2, TType.STRING, 'source', 'UTF8', None, ),  # 2
    (3, TType.I64, 'time', None, None, ),  # 3
    (4, TType.I64, 'uuid', None, None, ),  # 4
    (5, TType.STRING, 'topic', 'UTF8', None, ),  # 5
)
all_structs.append(SheepEvent)
SheepEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'wool', 'UTF8', None, ),  # 1
)
all_structs.append(PingEvent)
PingEvent.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'requestTime', None, None, ),  # 1
)
all_structs.append(PongEvent)
PongEvent.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'requestTime', None, None, ),  # 1
    (2, TType.I64, 'responseTime', None, None, ),  # 2
)
all_structs.append(ConnectionEstablishedEvent)
ConnectionEstablishedEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'clientIP', 'UTF8', None, ),  # 2
)
all_structs.append(ConnectionLostEvent)
ConnectionLostEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'clientIP', 'UTF8', None, ),  # 2
)
all_structs.append(Version)
Version.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'major', None, None, ),  # 1
    (2, TType.I32, 'minor', None, None, ),  # 2
    (3, TType.I32, 'patch', None, None, ),  # 3
)
all_structs.append(ServiceDescriptor)
ServiceDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'type', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'version', [Version, None], None, ),  # 3
    None,  # 4
    (5, TType.STRING, 'uri', 'UTF8', None, ),  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.MAP, 'arguments', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 10
    (11, TType.LIST, 'data', (TType.STRING, 'BINARY', False), None, ),  # 11
    (12, TType.STRING, 'context', 'UTF8', "", ),  # 12
)
all_structs.append(DiscoverEvent)
DiscoverEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'typeRegex', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'context', 'UTF8', "", ),  # 2
)
all_structs.append(AdvertiseEvent)
AdvertiseEvent.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'services', (TType.STRUCT, [ServiceDescriptor, None], False), None, ),  # 1
)
all_structs.append(IPResolveRequest)
IPResolveRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'requestId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
)
all_structs.append(IPResolveResponse)
IPResolveResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'responseId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ip', 'UTF8', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
